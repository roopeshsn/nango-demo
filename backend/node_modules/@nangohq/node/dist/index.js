import axios from 'axios';
import { AuthModes } from './types.js';
import { validateProxyConfiguration, validateSyncRecordConfiguration } from './utils.js';
export const stagingHost = 'https://api-staging.nango.dev';
export const prodHost = 'https://api.nango.dev';
export var SyncType;
(function (SyncType) {
    SyncType["INITIAL"] = "INITIAL";
    SyncType["INCREMENTAL"] = "INCREMENTAL";
})(SyncType || (SyncType = {}));
export class Nango {
    serverUrl;
    secretKey;
    connectionId;
    providerConfigKey;
    isSync = false;
    dryRun = false;
    activityLogId;
    constructor(config) {
        config.host = config.host || prodHost;
        this.serverUrl = config.host;
        if (this.serverUrl.slice(-1) === '/') {
            this.serverUrl = this.serverUrl.slice(0, -1);
        }
        if (!config.secretKey) {
            throw new Error('You must specify a secret key (cf. documentation).');
        }
        try {
            new URL(this.serverUrl);
        }
        catch (err) {
            throw new Error(`Invalid URL provided for the Nango host: ${this.serverUrl}`);
        }
        this.secretKey = config.secretKey;
        this.connectionId = config.connectionId || '';
        this.providerConfigKey = config.providerConfigKey || '';
        if (config.isSync) {
            this.isSync = config.isSync;
        }
        if (config.dryRun) {
            this.dryRun = config.dryRun;
        }
        if (config.activityLogId) {
            this.activityLogId = config.activityLogId;
        }
    }
    /**
     * For OAuth 2: returns the access token directly as a string.
     * For OAuth 2: If you want to obtain a new refresh token from the provider before the current token has expired,
     * you can set the forceRefresh argument to true."
     * For OAuth 1: returns an object with 'oAuthToken' and 'oAuthTokenSecret' fields.
     * @param providerConfigKey - This is the unique Config Key for the integration
     * @param connectionId - This is the unique connection identifier used to identify this connection
     * @param [forceRefresh] - When set, this is used to  obtain a new refresh token from the provider before the current token has expired,
     * you can set the forceRefresh argument to true.
     * */
    async getToken(providerConfigKey, connectionId, forceRefresh) {
        const response = await this.getConnectionDetails(providerConfigKey, connectionId, forceRefresh);
        switch (response.data.credentials.type) {
            case AuthModes.OAuth2:
                return response.data.credentials.access_token;
            case AuthModes.OAuth1:
                return { oAuthToken: response.data.credentials.oauth_token, oAuthTokenSecret: response.data.credentials.oauth_token_secret };
            default:
                return response.data.credentials;
        }
    }
    /**
     * Get the full (fresh) credentials payload returned by the external API,
     * which also contains access credentials.
     * @param providerConfigKey - This is the unique Config Key for the integration
     * @param connectionId - This is the unique connection identifier used to identify this connection
     * @param [forceRefresh] - When set, this is used to  obtain a new refresh token from the provider before the current token has expired,
     * you can set the forceRefresh argument to true.
     * */
    async getRawTokenResponse(providerConfigKey, connectionId, forceRefresh) {
        const response = await this.getConnectionDetails(providerConfigKey, connectionId, forceRefresh);
        const credentials = response.data.credentials;
        return credentials.raw;
    }
    /**
     * Get the Connection object, which also contains access credentials and full credentials payload
     * returned by the external API.
     * @param providerConfigKey - This is the unique Config Key for the integration
     * @param connectionId - This is the unique connection identifier used to identify this connection
     * @param [forceRefresh] - When set, this is used to  obtain a new refresh token from the provider before the current token has expired,
     * you can set the forceRefresh argument to true.
     * @param [refreshToken] - When set this returns the refresh token as part of the response
     */
    async getConnection(providerConfigKey, connectionId, forceRefresh, refreshToken) {
        const response = await this.getConnectionDetails(providerConfigKey, connectionId, forceRefresh, refreshToken);
        return response.data;
    }
    async proxy(config) {
        if (!config.connectionId && this.connectionId) {
            config.connectionId = this.connectionId;
        }
        if (!config.providerConfigKey && this.providerConfigKey) {
            config.providerConfigKey = this.providerConfigKey;
        }
        validateProxyConfiguration(config);
        const { providerConfigKey, connectionId, method, retries, headers: customHeaders, baseUrlOverride } = config;
        const url = `${this.serverUrl}/proxy${config.endpoint[0] === '/' ? '' : '/'}${config.endpoint}`;
        const customPrefixedHeaders = customHeaders && Object.keys(customHeaders).length > 0
            ? Object.keys(customHeaders).reduce((acc, key) => {
                acc[`Nango-Proxy-${key}`] = customHeaders[key];
                return acc;
            }, {})
            : {};
        const headers = {
            'Connection-Id': connectionId,
            'Provider-Config-Key': providerConfigKey,
            'Base-Url-Override': baseUrlOverride || '',
            'Nango-Is-Sync': this.isSync,
            'Nango-Is-Dry-Run': this.dryRun,
            'Nango-Activity-Log-Id': this.activityLogId || '',
            ...customPrefixedHeaders
        };
        if (retries) {
            headers['Retries'] = retries;
        }
        const options = {
            headers: this.enrichHeaders(headers)
        };
        if (config.params) {
            options.params = config.params;
        }
        if (config.paramsSerializer) {
            options.paramsSerializer = config.paramsSerializer;
        }
        if (this.dryRun) {
            console.log(`Nango Proxy Request: ${method?.toUpperCase()} ${url}`);
        }
        if (method?.toUpperCase() === 'POST') {
            return axios.post(url, config.data, options);
        }
        else if (method?.toUpperCase() === 'PATCH') {
            return axios.patch(url, config.data, options);
        }
        else if (method?.toUpperCase() === 'PUT') {
            return axios.put(url, config.data, options);
        }
        else if (method?.toUpperCase() === 'DELETE') {
            return axios.delete(url, options);
        }
        else {
            return axios.get(url, options);
        }
    }
    async get(config) {
        return this.proxy({
            ...config,
            method: 'GET'
        });
    }
    async post(config) {
        return this.proxy({
            ...config,
            method: 'POST'
        });
    }
    async patch(config) {
        return this.proxy({
            ...config,
            method: 'PATCH'
        });
    }
    async delete(config) {
        return this.proxy({
            ...config,
            method: 'DELETE'
        });
    }
    async getRecords(config) {
        const { connectionId, providerConfigKey, model, delta, offset, limit, includeNangoMetadata } = config;
        validateSyncRecordConfiguration(config);
        const order = config?.order === 'asc' ? 'asc' : 'desc';
        let sortBy = 'id';
        switch (config.sortBy) {
            case 'createdAt':
                sortBy = 'created_at';
                break;
            case 'updatedAt':
                sortBy = 'updated_at';
                break;
        }
        let filter = '';
        switch (config.filter) {
            case 'deleted':
                filter = 'deleted';
                break;
            case 'updated':
                filter = 'updated';
                break;
            case 'added':
                filter = 'added';
                break;
        }
        const includeMetadata = includeNangoMetadata || false;
        const url = `${this.serverUrl}/sync/records/?model=${model}&order=${order}&delta=${delta || ''}&offset=${offset || ''}&limit=${limit || ''}&sort_by=${sortBy || ''}&include_nango_metadata=${includeMetadata}&filter=${filter}`;
        const headers = {
            'Connection-Id': connectionId,
            'Provider-Config-Key': providerConfigKey
        };
        const options = {
            headers: this.enrichHeaders(headers)
        };
        const response = await axios.get(url, options);
        return response.data;
    }
    async getConnectionDetails(providerConfigKey, connectionId, forceRefresh = false, refreshToken = false, additionalHeader = {}) {
        const url = `${this.serverUrl}/connection/${connectionId}`;
        const headers = {
            'Content-Type': 'application/json',
            'Accept-Encoding': 'application/json'
        };
        if (additionalHeader) {
            Object.assign(headers, additionalHeader);
        }
        const params = {
            provider_config_key: providerConfigKey,
            force_refresh: forceRefresh,
            refresh_token: refreshToken
        };
        return axios.get(url, { params: params, headers: this.enrichHeaders(headers) });
    }
    /**
     * Get the list of Connections, which does not contain access credentials.
     */
    async listConnections(connectionId) {
        const response = await this.listConnectionDetails(connectionId);
        return response.data;
    }
    async getIntegration(providerConfigKey, includeIntegrationCredetials = false) {
        const url = `${this.serverUrl}/config/${providerConfigKey}`;
        const response = await axios.get(url, { headers: this.enrichHeaders({}), params: { include_creds: includeIntegrationCredetials } });
        return response.data;
    }
    async setMetadata(providerConfigKey, connectionId, metadata) {
        if (!providerConfigKey) {
            throw new Error('Provider Config Key is required');
        }
        if (!connectionId) {
            throw new Error('Connection Id is required');
        }
        if (!metadata) {
            throw new Error('Metadata is required');
        }
        const url = `${this.serverUrl}/connection/${connectionId}/metadata?provider_config_key=${providerConfigKey}`;
        const headers = {
            'Provider-Config-Key': providerConfigKey
        };
        return axios.post(url, metadata, { headers: this.enrichHeaders(headers) });
    }
    async setFieldMapping(_fieldMapping, _optionalProviderConfigKey, _optionalConnectionId) {
        throw new Error('setFieldMapping is deprecated. Please use setMetadata instead.');
    }
    async getMetadata(providerConfigKey, connectionId) {
        if (!providerConfigKey) {
            throw new Error('Provider Config Key is required');
        }
        if (!connectionId) {
            throw new Error('Connection Id is required');
        }
        const response = await this.getConnectionDetails(providerConfigKey, connectionId, false, false, {
            'Nango-Is-Sync': true,
            'Nango-Is-Dry-Run': this.dryRun
        });
        return response.data.metadata;
    }
    async getFieldMapping(_optionalProviderConfigKey, _optionalConnectionId) {
        throw new Error('getFieldMapping is deprecated. Please use getMetadata instead.');
    }
    async triggerSync(providerConfigKey, connectionId, syncs) {
        const url = `${this.serverUrl}/sync/trigger`;
        const headers = {
            'Connection-Id': connectionId,
            'Provider-Config-Key': providerConfigKey
        };
        if (typeof syncs === 'string') {
            throw new Error('Syncs must be an array of strings. If it is a single sync, please wrap it in an array.');
        }
        const body = {
            syncs: syncs || []
        };
        return axios.post(url, body, { headers: this.enrichHeaders(headers) });
    }
    async createConnection(_connectionArgs) {
        throw new Error('This method has been deprecated, please use the REST API to create a connection. See https://docs.nango.dev/api-reference/connection/post');
    }
    async deleteConnection(providerConfigKey, connectionId) {
        const url = `${this.serverUrl}/connection/${connectionId}?provider_config_key=${providerConfigKey}`;
        const headers = {
            'Content-Type': 'application/json',
            'Accept-Encoding': 'application/json'
        };
        return axios.delete(url, { headers: this.enrichHeaders(headers) });
    }
    async listConnectionDetails(connectionId) {
        let url = `${this.serverUrl}/connection?`;
        if (connectionId) {
            url = url.concat(`connectionId=${connectionId}`);
        }
        const headers = {
            'Content-Type': 'application/json',
            'Accept-Encoding': 'application/json'
        };
        return axios.get(url, { headers: this.enrichHeaders(headers) });
    }
    enrichHeaders(headers = {}) {
        headers['Authorization'] = 'Bearer ' + this.secretKey;
        return headers;
    }
}
//# sourceMappingURL=index.js.map