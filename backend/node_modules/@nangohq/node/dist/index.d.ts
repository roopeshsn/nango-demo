import { AxiosResponse } from 'axios';
import { AuthModes, OAuth1Credentials, OAuth2Credentials, ProxyConfiguration, GetRecordsRequestConfig, BasicApiCredentials, ApiKeyCredentials, Metadata, Connection, ConnectionList, Integration, IntegrationWithCreds } from './types.js';
export declare const stagingHost = "https://api-staging.nango.dev";
export declare const prodHost = "https://api.nango.dev";
interface NangoProps {
    host?: string;
    secretKey: string;
    connectionId?: string;
    providerConfigKey?: string;
    isSync?: boolean;
    dryRun?: boolean;
    activityLogId?: number;
}
interface CreateConnectionOAuth1 extends OAuth1Credentials {
    connection_id: string;
    provider_config_key: string;
    type: AuthModes.OAuth1;
}
interface OAuth1Token {
    oAuthToken: string;
    oAuthTokenSecret: string;
}
interface CreateConnectionOAuth2 extends OAuth2Credentials {
    connection_id: string;
    provider_config_key: string;
    type: AuthModes.OAuth2;
}
export declare enum SyncType {
    INITIAL = "INITIAL",
    INCREMENTAL = "INCREMENTAL"
}
export interface SyncResult {
    added: number;
    updated: number;
    deleted?: number;
}
export interface NangoSyncWebhookBody {
    connectionId: string;
    providerConfigKey: string;
    syncName: string;
    model: string;
    responseResults: SyncResult;
    syncType: SyncType;
    queryTimeStamp: string;
}
export declare class Nango {
    serverUrl: string;
    secretKey: string;
    connectionId?: string;
    providerConfigKey?: string;
    isSync: boolean;
    dryRun: boolean;
    activityLogId?: number;
    constructor(config: NangoProps);
    /**
     * For OAuth 2: returns the access token directly as a string.
     * For OAuth 2: If you want to obtain a new refresh token from the provider before the current token has expired,
     * you can set the forceRefresh argument to true."
     * For OAuth 1: returns an object with 'oAuthToken' and 'oAuthTokenSecret' fields.
     * @param providerConfigKey - This is the unique Config Key for the integration
     * @param connectionId - This is the unique connection identifier used to identify this connection
     * @param [forceRefresh] - When set, this is used to  obtain a new refresh token from the provider before the current token has expired,
     * you can set the forceRefresh argument to true.
     * */
    getToken(providerConfigKey: string, connectionId: string, forceRefresh?: boolean): Promise<string | OAuth1Token | BasicApiCredentials | ApiKeyCredentials>;
    /**
     * Get the full (fresh) credentials payload returned by the external API,
     * which also contains access credentials.
     * @param providerConfigKey - This is the unique Config Key for the integration
     * @param connectionId - This is the unique connection identifier used to identify this connection
     * @param [forceRefresh] - When set, this is used to  obtain a new refresh token from the provider before the current token has expired,
     * you can set the forceRefresh argument to true.
     * */
    getRawTokenResponse<T = Record<string, any>>(providerConfigKey: string, connectionId: string, forceRefresh?: boolean): Promise<T>;
    /**
     * Get the Connection object, which also contains access credentials and full credentials payload
     * returned by the external API.
     * @param providerConfigKey - This is the unique Config Key for the integration
     * @param connectionId - This is the unique connection identifier used to identify this connection
     * @param [forceRefresh] - When set, this is used to  obtain a new refresh token from the provider before the current token has expired,
     * you can set the forceRefresh argument to true.
     * @param [refreshToken] - When set this returns the refresh token as part of the response
     */
    getConnection(providerConfigKey: string, connectionId: string, forceRefresh?: boolean, refreshToken?: boolean): Promise<Connection>;
    proxy<T = any>(config: ProxyConfiguration): Promise<AxiosResponse<T>>;
    get<T = any>(config: ProxyConfiguration): Promise<AxiosResponse<T>>;
    post<T = any>(config: ProxyConfiguration): Promise<AxiosResponse<T>>;
    patch<T = any>(config: ProxyConfiguration): Promise<AxiosResponse<T>>;
    delete<T = any>(config: ProxyConfiguration): Promise<AxiosResponse<T>>;
    getRecords<T = any>(config: GetRecordsRequestConfig): Promise<T[]>;
    private getConnectionDetails;
    /**
     * Get the list of Connections, which does not contain access credentials.
     */
    listConnections(connectionId?: string): Promise<{
        connections: ConnectionList[];
    }>;
    getIntegration(providerConfigKey: string, includeIntegrationCredetials?: boolean): Promise<Integration | IntegrationWithCreds>;
    setMetadata(providerConfigKey: string, connectionId: string, metadata: Record<string, string>): Promise<AxiosResponse<void>>;
    setFieldMapping(_fieldMapping: Record<string, string>, _optionalProviderConfigKey?: string, _optionalConnectionId?: string): Promise<AxiosResponse<void>>;
    getMetadata<T = Metadata>(providerConfigKey: string, connectionId: string): Promise<T>;
    getFieldMapping(_optionalProviderConfigKey?: string, _optionalConnectionId?: string): Promise<Record<string, string>>;
    triggerSync(providerConfigKey: string, connectionId: string, syncs?: string[]): Promise<void>;
    createConnection(_connectionArgs: CreateConnectionOAuth1 | (CreateConnectionOAuth2 & {
        metadata: string;
        connection_config: string;
    })): Promise<void>;
    deleteConnection(providerConfigKey: string, connectionId: string): Promise<void>;
    private listConnectionDetails;
    private enrichHeaders;
}
export {};
